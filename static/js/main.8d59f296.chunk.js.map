{"version":3,"sources":["hooks/setup.js","hooks/postureObserver.js","component/LoadingSpinner.jsx","component/PageContainer.jsx","App.js","serviceWorker.js","index.js"],"names":["setupAndStartModel","setPoseNet","a","posenet","poseNetModel","drawKeyPoints","keypoints","canvasRef","skeletonColor","forEach","keypoint","score","KEYPOINT_CONFIDENCE","position","x","y","beginPath","arc","Math","PI","fillStyle","fill","POSTURE_ERROR_TYPES","HEAD_TILT_RIGHT","message","type","HEAD_TILT_LEFT","DEFAULT","postureObserverHelper","startingPoints","headTiltCalc","minDeviationPercentage","minPartConfidenceScore","minDiff","filteredStartingPoints","filter","part","includes","filteredkeyPoints","some","xDiff","abs","isHeadTilted","rotate","keyframes","LoadingSpinner","styled","div","LoadingContainer","videoIsReady","isModelReady","renderLoadingMessage","Container","Pose","videoRef","useRef","keyPointsRef","defaultPostureState","timeOutOfPosition","neckTiltLeftState","neckTiltRightState","useState","setStartingPoints","postureError","setIsOutOfPostureError","videoError","setVideoError","setVideoIsReady","useEffect","navigator","mediaDevices","getUserMedia","video","facingMode","width","VIDEO_VARIABLES","height","then","stream","current","srcObject","onloadedmetadata","e","play","catch","err","useWebCam","model","poseNet","usePoseNet","requestId","canvasContext","getContext","estimate","estimateSinglePose","flipHorizontal","drawImage","MINIMUM_CONFIDENCE_SCORE","length","postureCalc","SECONDS_TO_ERROR","errorSet","requestAnimationFrame","animate","cancelAnimationFrame","console","log","PageContainer","style","zIndex","ref","autoPlay","id","marginTop","disabled","onClick","map","index","key","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","App","document","getElementById","serviceWorker","ready","registration","unregister","error"],"mappings":"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","file":"static/js/main.8d59f296.chunk.js","sourcesContent":["import { useEffect, useState } from \"react\";\nimport * as posenet from \"@tensorflow-models/posenet\";\nimport { VIDEO_VARIABLES, KEYPOINT_CONFIDENCE } from '../config.json';\n\nconst setupAndStartModel = async setPoseNet => {\n  const poseNetModel = await posenet.load();\n  setPoseNet(poseNetModel);\n};\n\nexport const usePoseNet = ({ videoRef, videoIsReady }) => {\n  const [poseNet, setPoseNet] = useState(null);\n  useEffect(() => {\n    if (videoIsReady) {\n      setupAndStartModel(setPoseNet);\n    }\n  }, [videoRef, videoIsReady]);\n  return poseNet;\n};\n\nexport const useWebCam = ({ videoRef }) => {\n  const [videoError, setVideoError] = useState(null);\n  const [videoIsReady, setVideoIsReady] = useState(false);\n\n  useEffect(() => {\n    navigator.mediaDevices\n      .getUserMedia({ video: { facingMode: \"environment\", video: { width: VIDEO_VARIABLES.width, height: VIDEO_VARIABLES.height} } })\n      .then((stream) => {\n        videoRef.current.srcObject = stream;\n        videoRef.current.onloadedmetadata = function(e) {\n          videoRef.current.play();\n          setVideoIsReady(true);\n        };\n        videoRef.current.width = VIDEO_VARIABLES.width;\n        videoRef.current.height = VIDEO_VARIABLES.height;\n      })\n      .catch((err) => setVideoError(err));\n  // reasoning: need to only render on mount or else it'll keep trying to grab the user's media\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return { videoError, videoIsReady };\n}\n\nexport const drawKeyPoints = (\n  keypoints,\n  canvasRef,\n  skeletonColor = \"green\"\n) => {\n  keypoints.forEach((keypoint) => {\n    if (keypoint.score >= KEYPOINT_CONFIDENCE) {\n      const { x, y } = keypoint.position;\n      canvasRef.beginPath();\n      canvasRef.arc(x, y, 4, 0, 2 * Math.PI, false)\n      canvasRef.fillStyle = skeletonColor;\n      canvasRef.fill();\n    }\n  });\n};\n\n","const LIST_OF_BODY_PARTS = [\n  \"nose\",\n  \"leftEye\",\n  \"rightEye\",\n  \"leftEar\",\n  \"rightEar\",\n];\n\nexport const POSTURE_ERROR_TYPES = {\n  HEAD_TILT_RIGHT: { message: 'leaning to the right too much', type: 'HEAD_TILT_RIGHT' },\n  HEAD_TILT_LEFT: { message: 'leaning to the left too much', type: 'HEAD_TILT_LEFT' },\n  DEFAULT: { message: 'you\\'ve moved too far from the starting points ', type: 'DEFAULT'}\n}\n\nconst isHeadTilted = ({\n  keypoints,\n  startingPoints,\n  minPartConfidenceScore = 0.99,\n  minDiff = 5\n}) => {\n  const filteredStartingPoints = startingPoints.filter(({ part }) =>\n    [\"leftEye\", \"rightEye\"].includes(part)\n  );\n\n  const filteredkeyPoints = keypoints.filter(({ part }) => [\"leftEye\", \"rightEye\"].includes(part))\n\n  // check confidence for both eyes\n  if (filteredkeyPoints.some(({ score }) => score < minPartConfidenceScore)) {\n    return [{ message: 'confidence score for eyes not met', type: 'headTilt' }]\n  }\n\n  // only need to look at one of the 2 eyes\n  // const slope = (filteredStartingPoints[0].position.y - filteredkeyPoints[0].position.y) / (filteredStartingPoints[0].position.x - filteredkeyPoints[0].position.x);\n  // console.log(`y1: ${filteredStartingPoints[0].position.y}, y2: ${filteredkeyPoints[0].position.y}, x1 ${filteredStartingPoints[0].position.x}, x2 ${filteredkeyPoints[0].position.x}`)\n  // console.log(slope);\n  const xDiff = filteredStartingPoints[0].position.x - filteredkeyPoints[0].position.x\n  if (xDiff > 0 && Math.abs(xDiff) > minDiff) {\n    return [POSTURE_ERROR_TYPES.HEAD_TILT_RIGHT];\n  } else if (xDiff < 0 && Math.abs(xDiff) > minDiff) {\n    return [POSTURE_ERROR_TYPES.HEAD_TILT_LEFT];\n  }\n\n  return [];\n};\n\nexport const postureObserverHelper = ({\n  keypoints,\n  startingPoints,\n  minDeviationPercentage = 40,\n}) => {\n  // const filteredStartingPoints = startingPoints.filter(({ part }) =>\n  //   LIST_OF_BODY_PARTS.includes(part)\n  // );\n\n  const headTiltCalc = isHeadTilted({ keypoints, startingPoints });\n\n  // const isPostureFaulty = keypoints\n  //   .filter(({ part }) => LIST_OF_BODY_PARTS.includes(part))\n  //   .some((keypoint, index) => {\n  //     if (filteredStartingPoints[index].part !== keypoint.part) {\n  //       return true;\n  //     }\n  //     const xDiff = Math.abs(\n  //       filteredStartingPoints[index].position.x - keypoint.position.x\n  //     );\n  //     const yDiff = Math.abs(\n  //       filteredStartingPoints[index].position.y - keypoint.position.y\n  //     );\n  //     // use pythagorean theorem to get the true difference betwen points\n  //     const difference = Math.sqrt(Math.pow(xDiff, 2) + Math.pow(yDiff, 2));\n  //     if (difference > minDeviationPercentage) {\n  //       return true;\n  //     }\n  //     return false;\n  //   }, []);\n\n  //   const defaultCalc = isPostureFaulty ? [POSTURE_ERROR_TYPES.DEFAULT] : [];\n\n  return [...headTiltCalc];\n};\n","import React from \"react\";\n\nimport styled, { keyframes } from \"styled-components\";\n\n// credit to https://loading.io/css/\n\nconst rotate = keyframes`\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n`;\n\nconst LoadingSpinner = styled.div`\n  width: 80px;\n  height: 80px;\n  margin-top: 10%;\n\n  &:after {\n    content: \" \";\n    display: block;\n    width: 64px;\n    height: 64px;\n    margin: 8px;\n    border-radius: 50%;\n    border: 6px solid black;\n    border-color: black transparent black transparent;\n    animation: ${rotate} 1.2s linear infinite;\n  }\n`;\n\nconst LoadingContainer = styled.div`\n  z-index: 1;\n  height: 100vh;\n  width: 100vw;\n  background: white;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n`\n\nexport default ({ videoIsReady, isModelReady }) => {\n\n  const renderLoadingMessage = (videoIsReady, isModelReady) => {\n    if (!videoIsReady && !isModelReady) {\n        return \"preparing webcam\";\n    } else if (videoIsReady && !isModelReady) {\n        return \"loading pose model\";\n    } else {\n        return \"\";\n    }\n  };\n\n  if (videoIsReady && isModelReady) {\n    return null;\n  }\n\n  return (\n    <LoadingContainer>\n      <LoadingSpinner />\n      <p>{renderLoadingMessage(videoIsReady, isModelReady)}</p>\n    </LoadingContainer>\n  );\n};\n","import styled from \"styled-components\";\n\nconst Container = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n`\nexport default Container;\n","import React, { useRef, useEffect, useState } from \"react\";\n\nimport { usePoseNet, useWebCam, drawKeyPoints } from \"./hooks/setup\";\nimport { postureObserverHelper, POSTURE_ERROR_TYPES } from './hooks/postureObserver';\n\nimport LoadingSpinner from './component/LoadingSpinner';\nimport PageContainer from './component/PageContainer';\nimport { VIDEO_VARIABLES, MINIMUM_CONFIDENCE_SCORE, SECONDS_TO_ERROR } from './config.json';\n\nconst Pose = () => {\n  const videoRef = useRef();\n  const canvasRef = useRef();\n  const keyPointsRef = useRef([]);\n  const defaultPostureState = useRef({ timeOutOfPosition: 0, ...POSTURE_ERROR_TYPES.DEFAULT });\n  const neckTiltLeftState = useRef({ timeOutOfPosition: 0, ...POSTURE_ERROR_TYPES.HEAD_TILT_LEFT });\n  const neckTiltRightState = useRef({ timeOutOfPosition: 0, ...POSTURE_ERROR_TYPES.HEAD_TILT_RIGHT });;\n\n  const [startingPoints, setStartingPoints] = useState([]);\n  const [postureError, setIsOutOfPostureError] = useState([]);\n\n  // SETUP CAMERA\n  const { videoIsReady, videoError } = useWebCam({ videoRef });\n\n  // SETUP POSENET WHEN CAMERA IS READY\n  const model = usePoseNet({ videoRef, videoIsReady });\n\n  // ONLY WHEN CAMERA AND POSENET IS READY, START RECORDING POSES\n  useEffect(() => {\n    let requestId;\n\n    function cleanUp() {\n      cancelAnimationFrame(requestId)\n    }\n\n    if (videoIsReady && !!model) {\n      const canvasContext = canvasRef.current.getContext(\"2d\");\n      const estimate = async () => {\n        const { keypoints, score } = await model.estimateSinglePose(videoRef.current,{ flipHorizontal: false });\n        canvasContext.drawImage(\n          videoRef.current,\n          0,\n          0,\n          VIDEO_VARIABLES.width,\n          VIDEO_VARIABLES.height\n        );\n        if (score >= MINIMUM_CONFIDENCE_SCORE) {\n          keyPointsRef.current = keypoints;\n          drawKeyPoints(keypoints, canvasContext);\n        }\n        if (startingPoints.length > 0 && postureError.length === 0) {\n          const postureCalc = postureObserverHelper({ keypoints: keyPointsRef.current, startingPoints });\n          if (postureCalc.length === 0) {\n            defaultPostureState.current.timeOutOfPosition = 0;\n            neckTiltLeftState.current.timeOutOfPosition = 0;\n            neckTiltRightState.current.timeOutOfPosition = 0;\n          }\n          if (defaultPostureState.current.timeOutOfPosition === SECONDS_TO_ERROR ||\n            neckTiltLeftState.current.timeOutOfPosition === SECONDS_TO_ERROR ||\n            neckTiltRightState.current.timeOutOfPosition === SECONDS_TO_ERROR) {\n            const errorSet = [defaultPostureState.current, neckTiltRightState.current, neckTiltLeftState.current].filter(({\n              timeOutOfPosition\n            }) => timeOutOfPosition === 600 );\n            setIsOutOfPostureError(errorSet);\n          } else {\n            if (postureCalc.some(({ type }) => type === POSTURE_ERROR_TYPES.DEFAULT.type)) {\n              defaultPostureState.current.timeOutOfPosition ++;\n            }\n            if (postureCalc.some(({ type }) => type === POSTURE_ERROR_TYPES.HEAD_TILT_LEFT.type)) {\n              neckTiltLeftState.current.timeOutOfPosition ++;\n            }\n            if (postureCalc.some(({ type }) => type === POSTURE_ERROR_TYPES.HEAD_TILT_RIGHT.type)) {\n              neckTiltRightState.current.timeOutOfPosition ++;\n            }\n          }\n        }\n      };\n\n      function animate() {\n        estimate();\n        requestId = requestAnimationFrame(animate);\n      }\n      requestId = requestAnimationFrame(animate);\n    }\n    return cleanUp;\n  });\n\n  if (videoError) {\n    console.log(videoError);\n    return (\n      <div>\n        there was an error loading, make sure your browser supports webcam or\n        that your webcam is turned on\n      </div>\n    );\n  }\n\n  return (\n    <PageContainer>\n      <LoadingSpinner videoIsReady={videoIsReady} isModelReady={!!model} />\n      <video\n        style={{ position: \"fixed\", zIndex: -1 }}\n        ref={videoRef}\n        autoPlay\n      ></video>\n      <canvas\n        width={VIDEO_VARIABLES.width}\n        height={VIDEO_VARIABLES.height}\n        ref={canvasRef}\n        id=\"c1\"\n      ></canvas>\n      {(videoIsReady || !!model) && (\n        <div style={{ marginTop: \"30px\" }}>\n          <button disabled={startingPoints.length > 0 && postureError.length === 0} onClick={() => {\n            setIsOutOfPostureError([]);\n            setStartingPoints(keyPointsRef.current);\n            defaultPostureState.current.timeOutOfPosition = 0;\n            neckTiltLeftState.current.timeOutOfPosition = 0;\n            neckTiltRightState.current.timeOutOfPosition = 0;\n          }}>\n            Set starting points\n          </button>\n          <button onClick={() => {\n            setStartingPoints([]);\n          }}>\n            Stop posture tracking\n          </button>\n          {postureError.length > 0 && (\n            <div>\n              <p>uh oh you're out of positions for the reasons below, when you're ready press the set starting points to reset</p>\n              {postureError.map(({ message }, index) => (\n                <div key={index}>\n                  <p>{message}</p>\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n      )}\n    </PageContainer>\n  );\n};\n\nexport default Pose;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}