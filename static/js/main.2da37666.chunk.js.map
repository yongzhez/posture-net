{"version":3,"sources":["hooks/poseNetSetup.js","hooks/postureObserver.js","App.js","serviceWorker.js","index.js"],"names":["setupAndStartModel","setPoseNet","a","posenet","architecture","outputStride","inputResolution","VIDEO_VARIABLES","quantBytes","poseNetModel","drawKeyPoints","keypoints","canvasRef","skeletonColor","forEach","keypoint","score","KEYPOINT_CONFIDENCE","position","x","y","beginPath","arc","Math","PI","fillStyle","fill","usePoseNet","videoRef","videoIsReady","useState","poseNet","useEffect","LIST_OF_BODY_PARTS","postureObserverHelper","startingPoints","minDeviationPercentage","filteredStartingPoints","filter","part","includes","some","index","xDiff","abs","yDiff","sqrt","pow","Pose","useRef","keyPointsRef","setStartingPoints","setVideoIsReady","videoError","setVideoError","navigator","mediaDevices","getUserMedia","video","facingMode","width","height","then","stream","current","srcObject","onloadedmetadata","e","play","catch","err","model","requestId","canvasContext","getContext","estimate","estimateSinglePose","flipHorizontal","drawImage","MINIMUM_CONFIDENCE_SCORE","length","isPostureOkay","console","log","requestAnimationFrame","animate","cancelAnimationFrame","style","zIndex","ref","autoPlay","id","onClick","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","App","document","getElementById","serviceWorker","ready","registration","unregister","error","message"],"mappings":"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","file":"static/js/main.2da37666.chunk.js","sourcesContent":["import { useEffect, useState } from \"react\";\nimport * as posenet from \"@tensorflow-models/posenet\";\nimport { VIDEO_VARIABLES, KEYPOINT_CONFIDENCE } from '../config.json';\n\nconst setupAndStartModel = async setPoseNet => {\n  const poseNetModel = await posenet.load({\n    architecture: \"ResNet50\",\n    outputStride: 32,\n    inputResolution: VIDEO_VARIABLES,\n    quantBytes: 2,\n  });\n  setPoseNet(poseNetModel);\n};\n\nconst usePoseNet = ({ videoRef, videoIsReady }) => {\n  const [poseNet, setPoseNet] = useState(null);\n  useEffect(() => {\n    if (videoIsReady) {\n      setupAndStartModel(setPoseNet);\n    }\n  }, [videoRef, videoIsReady]);\n  return poseNet;\n};\n\nexport const drawKeyPoints = (\n  keypoints,\n  canvasRef,\n  skeletonColor = \"green\"\n) => {\n  keypoints.forEach((keypoint) => {\n    if (keypoint.score >= KEYPOINT_CONFIDENCE) {\n      const { x, y } = keypoint.position;\n      canvasRef.beginPath();\n      canvasRef.arc(x, y, 4, 0, 2 * Math.PI, false)\n      canvasRef.fillStyle = skeletonColor;\n      canvasRef.fill();\n    }\n  });\n};\n\nexport default usePoseNet;\n","\nconst LIST_OF_BODY_PARTS = [\n    \"nose\",\n    \"leftEye\",\n    \"rightEye\",\n    \"leftEar\",\n    \"rightEar\"\n]\n\nexport const postureObserverHelper = ({\n    keypoints,\n    startingPoints,\n    minDeviationPercentage\n}) => {\n    const filteredStartingPoints = startingPoints.filter(({ part }) => LIST_OF_BODY_PARTS.includes(part))\n    const isPostureFaulty =  keypoints\n    .filter(({ part }) => LIST_OF_BODY_PARTS.includes(part))\n    .some((keypoint,index) => {\n        if (filteredStartingPoints[index].part !== keypoint.part) {\n            return true;\n        }\n        const xDiff = Math.abs(filteredStartingPoints[index].position.x - keypoint.position.x);\n        const yDiff = Math.abs(filteredStartingPoints[index].position.y - keypoint.position.y);\n        // use pythagorean theorem to get the true difference betwen points\n        const difference = Math.sqrt(Math.pow(xDiff, 2) + Math.pow(yDiff, 2))\n        if (difference > minDeviationPercentage) {\n            return true;\n        }\n        return false;\n    },[])\n    return !isPostureFaulty;\n}","import React, { useRef, useEffect, useState } from \"react\";\nimport usePoseNet, { drawKeyPoints } from \"./hooks/poseNetSetup\";\nimport { postureObserverHelper } from './hooks/postureObserver';\n\nimport { VIDEO_VARIABLES, MINIMUM_CONFIDENCE_SCORE } from './config.json';\n\nconst Pose = () => {\n  const videoRef = useRef();\n  const canvasRef = useRef();\n  const keyPointsRef = useRef([]);\n\n  const [startingPoints, setStartingPoints] = useState([]);\n  const [videoIsReady, setVideoIsReady] = useState(false);\n  const [videoError, setVideoError] = useState(null);\n\n  // SETUP CAMERA\n  useEffect(() => {\n    navigator.mediaDevices\n      .getUserMedia({ video: { facingMode: \"environment\", video: { width: VIDEO_VARIABLES.width, height: VIDEO_VARIABLES.height} } })\n      .then((stream) => {\n        videoRef.current.srcObject = stream;\n        videoRef.current.onloadedmetadata = function(e) {\n          videoRef.current.play();\n          setVideoIsReady(true);\n        };\n        videoRef.current.width = VIDEO_VARIABLES.width;\n        videoRef.current.height = VIDEO_VARIABLES.height;\n      })\n      .catch((err) => setVideoError(err));\n  }, []);\n\n  // SETUP POSENET WHEN CAMERA IS READY\n  const model = usePoseNet({ videoRef, videoIsReady });\n\n  // ONLY WHEN CAMERA AND POSENET IS READY, START RECORDING POSES\n  useEffect(() => {\n    let requestId;\n    const canvasContext = canvasRef.current.getContext(\"2d\");\n\n    function cleanUp() {\n      cancelAnimationFrame(requestId)\n    }\n\n    if (videoIsReady && !!model) {\n      const estimate = async () => {\n        const { keypoints, score } = await model.estimateSinglePose(videoRef.current,{ flipHorizontal: false });\n        canvasContext.drawImage(\n          videoRef.current,\n          0,\n          0,\n          VIDEO_VARIABLES.width,\n          VIDEO_VARIABLES.height\n        );\n        if (score >= MINIMUM_CONFIDENCE_SCORE) {\n          keyPointsRef.current = keypoints;\n          drawKeyPoints(keypoints, canvasContext);\n        }\n        if (startingPoints.length > 0) {\n          let isPostureOkay = postureObserverHelper({ keypoints: keyPointsRef.current, startingPoints, minDeviationPercentage: 40});\n          console.log(isPostureOkay);\n        }\n      };\n\n      function animate() {\n        estimate();\n        requestId = requestAnimationFrame(animate);\n      }\n      requestId = requestAnimationFrame(animate);\n    }\n    return cleanUp;\n  });\n\n  if (videoError) {\n    console.log(videoError);\n    return (\n      <div>\n        there was an error loading, make sure your browser supports webcam or\n        that your webcam is turned on\n      </div>\n    );\n  }\n\n  return (\n    <div>\n      <video\n        style={{ position: \"fixed\", zIndex: -1 }}\n        ref={videoRef}\n        autoPlay\n      ></video>\n      <canvas\n        width={VIDEO_VARIABLES.width}\n        height={VIDEO_VARIABLES.height}\n        ref={canvasRef}\n        id=\"c1\"\n      ></canvas>\n      <button onClick={() => {\n        setStartingPoints(keyPointsRef.current);\n      }}>\n        Set starting points\n      </button>\n      <button onClick={() => {\n        setStartingPoints([]);\n      }}>\n        Stop posture tracking\n      </button>\n    </div>\n  );\n};\n\nexport default Pose;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}